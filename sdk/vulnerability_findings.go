// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.

package sdk

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
)

// ListVulnerabilityFindings streams vulnerability findings page by page via a channel.
// This is memory-efficient for large datasets. The channel will be closed when done.
// Returns an error channel that will receive any error that occurs during streaming.
//
// Example - streaming (memory efficient):
//
//	findings, errCh := client.ListVulnerabilityFindings(ctx, query)
//	for finding := range findings {
//	    process(finding)
//	}
//	if err := <-errCh; err != nil {
//	    log.Fatal(err)
//	}
//
// Example - collect all (loads everything in memory):
//
//	findingsCh, errCh := client.ListVulnerabilityFindings(ctx, query)
//	allFindings, err := sdk.CollectAll(ctx, findingsCh, errCh)
func (c *Client) ListVulnerabilityFindings(ctx context.Context, query *VulnerabilityFindingsQuery) (<-chan VulnerabilityFinding, <-chan error) {
	findingsCh := make(chan VulnerabilityFinding, 100)
	errCh := make(chan error, 1)

	go func() {
		defer close(findingsCh)
		defer close(errCh)

		if query == nil {
			query = &VulnerabilityFindingsQuery{}
		}

		// Use default page size if not specified
		if query.PerPage == 0 {
			query.PerPage = c.config.PageSize
		}

		pageToken := ""
		for {
			findings, nextToken, err := c.listVulnerabilityFindingsPage(ctx, query, pageToken)
			if err != nil {
				errCh <- err
				return
			}

			for _, finding := range findings {
				select {
				case findingsCh <- finding:
				case <-ctx.Done():
					errCh <- ctx.Err()
					return
				}
			}

			if nextToken == "" {
				break
			}
			pageToken = nextToken
		}
	}()

	return findingsCh, errCh
}

// listVulnerabilityFindingsPage retrieves a single page of vulnerability findings
func (c *Client) listVulnerabilityFindingsPage(ctx context.Context, query *VulnerabilityFindingsQuery, pageToken string) ([]VulnerabilityFinding, string, error) {
	urlPath := fmt.Sprintf("%s/organizations/%s/vulnerability-findings", c.config.GetBaseURL(), c.config.OrganizationID)
	queryParams := c.buildVulnerabilityFindingsQueryParams(query, pageToken)

	if len(queryParams) > 0 {
		urlPath += "?" + queryParams
	}

	req, err := http.NewRequestWithContext(ctx, "GET", urlPath, nil)
	if err != nil {
		return nil, "", fmt.Errorf("creating request: %w", err)
	}

	resp, err := c.doRequest(ctx, req)
	if err != nil {
		return nil, "", fmt.Errorf("executing request: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK && resp.StatusCode != http.StatusPartialContent {
		body, _ := io.ReadAll(resp.Body)
		return nil, "", fmt.Errorf("API error %d: %s", resp.StatusCode, string(body))
	}

	var findings []VulnerabilityFinding
	if err := json.NewDecoder(resp.Body).Decode(&findings); err != nil {
		return nil, "", fmt.Errorf("decoding response: %w", err)
	}

	// Extract next page token from Link header
	nextToken, err := extractNextLink(resp.Header.Get("Link"))
	if err != nil {
		return nil, "", fmt.Errorf("parsing pagination link: %w", err)
	}

	// If nextToken is a full URL, extract just the page-token parameter value
	// We extract the raw value from the URL without using Query().Get() to avoid
	// decode/re-encode issues with the token format
	if nextToken != "" && strings.Contains(nextToken, "page-token=") {
		parsedURL, err := url.Parse(nextToken)
		if err == nil {
			// Get the raw query string and extract page-token manually
			rawQuery := parsedURL.RawQuery
			if rawQuery != "" {
				// Find page-token in the query string
				for _, param := range strings.Split(rawQuery, "&") {
					if strings.HasPrefix(param, "page-token=") {
						// Extract the raw token value (still URL-encoded)
						nextToken = strings.TrimPrefix(param, "page-token=")
						// Decode it once since params.Encode() will encode it again
						decoded, err := url.QueryUnescape(nextToken)
						if err == nil {
							nextToken = decoded
						}
						break
					}
				}
			}
		}
	}

	return findings, nextToken, nil
}

// GetVulnerabilityFinding retrieves a specific vulnerability finding by ID
func (c *Client) GetVulnerabilityFinding(ctx context.Context, findingID string) (*VulnerabilityFinding, error) {
	urlPath := fmt.Sprintf("%s/organizations/%s/vulnerability-findings/%s",
		c.config.GetBaseURL(), c.config.OrganizationID, findingID)

	req, err := http.NewRequestWithContext(ctx, "GET", urlPath, nil)
	if err != nil {
		return nil, fmt.Errorf("creating request: %w", err)
	}

	resp, err := c.doRequest(ctx, req)
	if err != nil {
		return nil, fmt.Errorf("executing request: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode == http.StatusNotFound {
		return nil, fmt.Errorf("vulnerability finding not found: %s", findingID)
	}

	if resp.StatusCode != http.StatusOK {
		body, _ := io.ReadAll(resp.Body)
		return nil, fmt.Errorf("API error %d: %s", resp.StatusCode, string(body))
	}

	var finding VulnerabilityFinding
	if err := json.NewDecoder(resp.Body).Decode(&finding); err != nil {
		return nil, fmt.Errorf("decoding response: %w", err)
	}

	return &finding, nil
}

// buildVulnerabilityFindingsQueryParams constructs URL query parameters for vulnerability findings
func (c *Client) buildVulnerabilityFindingsQueryParams(query *VulnerabilityFindingsQuery, pageToken string) string {
	params := url.Values{}

	if pageToken != "" {
		params.Add("page-token", pageToken)
	} else if query.PageToken != "" {
		params.Add("page-token", query.PageToken)
	}

	if query.PerPage > 0 {
		params.Add("per-page", fmt.Sprintf("%d", query.PerPage))
	}
	if query.CloudAccountID != "" {
		params.Add("cloud-account-id", query.CloudAccountID)
	}
	if query.ClusterID != "" {
		params.Add("cluster-id", query.ClusterID)
	}
	if query.Namespace != "" {
		params.Add("namespace", query.Namespace)
	}
	if query.IngressActiveCommunication != nil {
		params.Add("ingress-active-communication", fmt.Sprintf("%t", *query.IngressActiveCommunication))
	}
	if query.InternetExposure != nil {
		params.Add("internet-exposure", fmt.Sprintf("%t", *query.InternetExposure))
	}
	if query.InUse != nil {
		params.Add("in-use", fmt.Sprintf("%t", *query.InUse))
	}
	if query.Exploitable != nil {
		params.Add("exploitable", fmt.Sprintf("%t", *query.Exploitable))
	}
	if query.FixAvailable != nil {
		params.Add("fix-available", fmt.Sprintf("%t", *query.FixAvailable))
	}
	if query.Severity != "" {
		params.Add("severity", query.Severity)
	}
	if query.ImageName != "" {
		params.Add("image-name", query.ImageName)
	}
	if query.Framework != "" {
		params.Add("framework", query.Framework)
	}

	return params.Encode()
}
